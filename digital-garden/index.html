<!DOCTYPE html>
<html lang="en">
  <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />

    <title>grtnr.com</title>

    <meta charset="utf-8" />
    <link rel="stylesheet" href="../theme/css/poole.css"/>
    <link rel="stylesheet" href="../theme/css/syntax.css"/>
    <link rel="stylesheet" href="../theme/css/lanyon.css"/>
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
    <link rel="stylesheet" href="../theme/css/styles.css"/>




  </head>

  <body>
<!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">
<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  
    <div class="sidebar-item">Stuff that keeps me busy, like family, coding, math, mountains and more.</div>

  <nav class="sidebar-nav">

  <a class="sidebar-nav-item" href="../">Home</a>

  <a class="sidebar-nav-item" href="/tags">Topics</a>
  <a class="sidebar-nav-item" href="/recipes">Recipes</a>
  <a class="sidebar-nav-item" href="/about">About</a>
  <a class="sidebar-nav-item" href="/impressum">Impressum</a>

  </nav>

  <div class="sidebar-item">
    <p class="tiny-note">
      <a class="muted" href="https://github.com/thomaswilley/pelicanyan">pelicanyan v0.1</a>
    </p>
  </div>
</div>
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="../" title="Home">grtnr.com</a>
          </h3>
        </div>
      </div>

      <div class="container content">
<div class="posts">
<div class="post">
    <h1 class="post-title">
      Digital&nbsp;Garden
    </h1>
    <span class="post-date">April 18, 2025</span>

    <p><img alt="Digital garden" src="digital-garden.jpg"/></p>
<ul>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#technology-and-architecture">Technology andÂ Architecture</a></li>
<li><a href="#chatgpt-building-a-python-powered-digital-garden-stack--architecture">ChatGPT: Building a Python-Powered Digital Garden: Stack \&amp; Architecture</a><ul>
<li><a href="#static-site-generator--content-organization">Static Site Generator \&amp; ContentÂ Organization</a></li>
<li><a href="#markdown-editing--local-preview">Markdown Editing \&amp; LocalÂ Preview</a></li>
<li><a href="#wiki-style-internal-linking--backlinks">Wiki-Style Internal Linking \&amp;Â Backlinks</a></li>
<li><a href="#custom-content-types--templates">Custom Content Types \&amp;Â Templates</a></li>
<li><a href="#beautiful-theming-ghost-inspired-design">Beautiful Theming (Ghost-InspiredÂ Design)</a></li>
<li><a href="#multi-language-support--ai-translations">Multi-Language Support \&amp; <span class="caps">AI</span>Â Translations</a></li>
<li><a href="#content-access-control-roles--authentication">Content Access Control (Roles \&amp;Â Authentication)</a></li>
<li><a href="#tags-indexes-and-navigation-pages">Tags, Indexes, and NavigationÂ Pages</a></li>
<li><a href="#build-pipeline--link-validation">Build Pipeline \&amp; LinkÂ Validation</a></li>
<li><a href="#summary-of-the-recommended-stack">Summary of the RecommendedÂ Stack</a></li>
</ul>
</li>
<li><a href="#follow-up-questions">Follow up questions</a><ul>
<li><a href="#changing-the-structure">Changing theÂ structure</a></li>
<li><a href="#articles-or-pages">Articles orÂ Pages?</a></li>
</ul>
</li>
<li><a href="#playing-around">PlayingÂ around</a></li>
</ul>
<p>I read about Digital Gardens on <a href="https://www.heise.de/hintergrund/Nerd-Trend-Digitaler-Garten-Die-eigene-Website-als-persoenliches-Wissensarchiv-10344169.html" rel="noopener noreferrer" target="_blank">heise (in German)</a> and really liked the idea. The key differences to my current blog that I thought ofÂ are</p>
<ul>
<li>The idea of writing down ideas and starting articles right away - and having them in the garden immediatly. Thatâ€™s a big digfference to the attidude of â€œI need to finish the article before I publishÂ itâ€.</li>
<li>The idea of linking to other articles and creating a network of articles. Thatâ€™s something I can already do in my blog, but the process is delicate: If I rename or move an article around, the links to it are broken. Also the idea of backlinks isÂ striking.</li>
<li>Putting the topics more to the front rather than the date: My blog is primarely structured and presented by date. Having the topic(s) more as navigation structure seems compelling. Of course I would still lÃ¶eave the date of creation, as well as the date of the lastÂ modification.</li>
</ul>
<h1>Requirements</h1>
<p>As usual I tend to start by looking at the technical side ğŸ˜€. So I jotted down my requirements and asked ChatGPT forÂ help.</p>
<p>My requirements for a digital gardenÂ system:</p>
<ul>
<li>Articles are based on markdownÂ files.</li>
<li>Built as static generatedÂ website.</li>
<li>One article in one directory together with its resources: pictures, PDFs, other files. This way local rendering per article makes sense, very helpful while editing. I would edit the articles with VScode or another editor that has markdownÂ support.</li>
<li>Articles (i.e. their directories) can be in a directory tree structure. Their directory structure describes the category. ForÂ example/tech/dev/data_science</li>
<li>Written in Python, so I can tinkerÂ around.</li>
<li>Build pipeline can be completed: a stage to check internalÂ links.</li>
<li>Internal links as <em>[ [links] ]</em>. And show backlinks in linkedÂ articles.</li>
<li>I want to easily create specific article types with special structure, fields, rendering. Examples are <span class="caps">RECIPE</span>, <span class="caps">PLACE</span> or <span class="caps">LOCATION</span>, <span class="caps">TRIP</span> <span class="caps">ADVENTURE</span>,Â â€¦</li>
<li>Beautiful site! Not like a messy nerdy garden! Take inspiration from beautiful blogs likeÂ ghost.</li>
<li>Multilingual, with languages filled up by <span class="caps">AI</span> if not provided byÂ author.</li>
<li>Different access rights: some content is public, other for family <span class="amp">&amp;</span> friends or other userÂ groups.</li>
<li>Access roles, for example: articles that are unpublished can only be seen by users with role <span class="caps">EDITOR</span>.</li>
<li>Allow multiple index pages: tags, historical index (maybe also per tag), most read, most starredâ€¦ Index pages can be generated but also hand crafted. Specifically the homeÂ page.</li>
</ul>
<h1>Technology andÂ Architecture</h1>
<p><a href="https://chatgpt.com/share/68026bb5-d040-8009-9f79-ec0fd35880f4" rel="noopener noreferrer" target="_blank">This is what ChatGPT produced</a> (I thionk itâ€™s really good, so I paste it allÂ here):</p>
<p>Great. Iâ€™ll explore the best Python-based static site generators and architecture for building a beautifully styled, markdown-driven digital garden with support for access control, internal link checking, multilingual support, and article-type customization. Iâ€™ll also ensure the system supports your preferred local editing flow, generates plain <span class="caps">HTML</span>, and works well with GitHubÂ Pages.</p>
<p>Iâ€™ll get back to you with a recommended stack, architecture diagram, and suggestions on how to implement your requirementsÂ smoothly.</p>
<p><em>Researched for 11m 16s * 23Â sources</em></p>
<h1>ChatGPT: Building a Python-Powered Digital Garden: Stack <span class="amp">&amp;</span>Â Architecture</h1>
<h2>Static Site Generator <span class="amp">&amp;</span> ContentÂ Organization</h2>
<p>For a <strong>Python-based static site generator</strong>, <strong>Pelican</strong> is an excellent choice. Pelican is actively maintained and well-documented, supporting Markdown content and multi-language publishing out-of-the-box (<a href="https://github.com/getpelican/pelican#:~:text=,rich%20plugin%20ecosystem%3A%20Pelican%20Plugins" rel="noopener noreferrer" target="_blank">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>). It generates a plain <span class="caps">HTML</span> site (no need for React/Vue) and has a rich plugin ecosystem for extending functionality (<a href="https://github.com/getpelican/pelican#:~:text=,rich%20plugin%20ecosystem%3A%20Pelican%20Plugins" rel="noopener noreferrer" target="_blank">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>). </p>
<p><strong>Content Structure:</strong> Organize the digital gardenâ€™s content in a logical directory hierarchy underÂ Pelicanâ€™s <code>content/</code> folder. Each article lives in its own subdirectory alongside its assets. ForÂ example: </p>
<div class="highlight"><pre><span></span><code>content/
â”œâ”€â”€ tech/
â”‚   â””â”€â”€ dev/
â”‚        â””â”€â”€ data_science/
â”‚             â””â”€â”€ my-article/ 
â”‚                  â”œâ”€â”€ index.md        # Article in Markdown
â”‚                  â”œâ”€â”€ figure1.png     # Images/PDFs related to article
â”‚                  â””â”€â”€ data.pdf
â””â”€â”€ travel/
    â””â”€â”€ trip-to-paris/
         â”œâ”€â”€ index.md
         â””â”€â”€ eiffel.jpg
</code></pre></div>
<p>In this layout, every articleÂ (<code>index.md</code>) is grouped with its media. Pelican can handle â€œpage bundlesâ€ like this by treating those subfolders as both content and static paths. We configure Pelicanâ€™s settings to include each folderÂ in <code>ARTICLE_PATHS</code> and <code>STATIC_PATHS</code> so that markdown files are processed and assets are copied through to output (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=Starting%20with%20Pelican%203,directory%20reserved%20for%20static%20files" rel="noopener noreferrer" target="_blank">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>) (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=generated%20site,in%20earlier%20versions%20of%20Pelican" rel="noopener noreferrer" target="_blank">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>). Pelicanâ€™s <strong>attach syntax</strong> allows linking to local files easily: in Markdown,Â use <code>{attach}</code> to reference files in the same folder. ForÂ example: <code>![Figure]({attach}figure1.png)</code> in <code>my-article/index.md</code> will copy <em>figure1.png</em> into the articleâ€™s output directory and link to it (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=Starting%20with%20Pelican%203,sibling%20of%20the%20linking%20document" rel="noopener noreferrer" target="_blank">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>) (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=Title%3A%20Test%20Post%20Category%3A%20test,31" rel="noopener noreferrer" target="_blank">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>). This keeps images/PDFs co-located with their article and ensures links arenâ€™t broken after the static build (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=output%20%E2%94%94%E2%94%80%E2%94%80%202014%20%E2%94%9C%E2%94%80%E2%94%80%20archive,post.html" rel="noopener noreferrer" target="_blank">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>). </p>
<p>Pelican also supports using folder names as categories automatically. By default, the immediate parent folder becomes the category (e.g. â€œdata_scienceâ€ in the path above) (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=Note%20that%2C%20aside%20from%20the,W3C%E2%80%99s%20suggested%20subset%20ISO%208601" rel="noopener noreferrer" target="_blank">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>). We can preserve deeper nesting in URLs by customizing the save path. For instance,Â setting <code>ARTICLE_SAVE_AS = '{category}/{slug}/index.html'</code> andÂ similar <code>ARTICLE_URL</code> will output each post asÂ an <code>index.html</code> inside a folder matching its category/slug. This yields clean URLsÂ like <code>/tech/dev/data_science/my-article/</code> reflecting the directory structure.Â (Pelicanâ€™s <code>USE_FOLDER_AS_CATEGORY=True</code> by default uses the lowest folder as category; for multi-level taxonomy, one can either combine the path into one category or treat top folders as sections and use tags forÂ sub-classification.) </p>
<h2>Markdown Editing <span class="amp">&amp;</span> LocalÂ Preview</h2>
<p>All articles are written in plain <strong>Markdown</strong> (with <span class="caps">YAML</span>/<span class="caps">TOML</span> front matter for metadata) so you can comfortably author content in <span class="caps">VS</span> Code or any editor. Each Markdown file begins with metadata like title, date, tags, etc. Pelican only requires a title (it can derive others if needed) (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=Note%20that%2C%20aside%20from%20the,W3C%E2%80%99s%20suggested%20subset%20ISO%208601" rel="noopener noreferrer" target="_blank">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>), but weâ€™ll use metadata extensively for custom behavior (more on this later). A sample front matter for an article mightÂ be: </p>
<div class="highlight"><pre><span></span><code>Title: My Data Science Journey  
Date: 2025-04-10  
Category: data_science  
Tags: python, analytics  
Slug: my-data-science-journey  
Status: published  
</code></pre></div>
<p><strong>Local Preview:</strong> To enable per-article preview while editing, use Pelicanâ€™s built-in development server. Pelicanâ€™s <span class="caps">CLI</span>/Makefile supports an auto-reload serverÂ (e.g. <code>make devserver</code> or <code>pelican --autoreload --listen</code>) that watches for file changes and rebuilds as you write. This way, you can navigateÂ to <code>http://localhost:8000/tech/dev/data_science/my-article/</code> and see the rendered <span class="caps">HTML</span> update on each save. Because Pelican does selective output writing and caching, rebuilds are fast even for large sites (<a href="https://github.com/getpelican/pelican#:~:text=,rich%20plugin%20ecosystem%3A%20Pelican%20Plugins" rel="noopener noreferrer" target="_blank">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>). This gives a near real-time preview of the article in the context of the actual theme/template. For quick iteration on a single page, Pelicanâ€™s incremental build will detect only <em>my-article</em> has changed and regenerate just that page, making the feedback loop quick. <span class="caps">VS</span> Code can also preview Markdown, but using Pelicanâ€™s server ensures the content is seen with the final siteâ€™s styling andÂ layout. </p>
<h2>Wiki-Style Internal Linking <span class="amp">&amp;</span>Â Backlinks</h2>
<p>To interconnect notes in wiki fashion, we enable <strong>[[Wiki-Style]] linking</strong> in Markdown. Pelican has a community plugin called <strong>Wikilinks</strong> that automaticallyÂ converts <code>[[Page Name]]</code> syntax into proper hyperlinks between pages (<a href="https://github.com/MinchinWeb/minchin.pelican.plugins.wikilinks/#:~:text=Usage%20Notes" rel="noopener noreferrer" target="_blank">GitHub - minchinweb/minchin.pelican.plugins.wikilinks: Support Wikilinks when generating Pelican sites</a>). For example,Â writing <code>We build on ideas from [[My Data Science Journey]]</code> in another article will link to the â€œMy Data Science Journeyâ€ page (resolving to its slug or filename). The Wikilinks plugin supports optional display textÂ (e.g. <code>[[Page Name|custom text]]</code>) (<a href="https://github.com/MinchinWeb/minchin.pelican.plugins.wikilinks/#:~:text=Usage%20Notes" rel="noopener noreferrer" target="_blank">GitHub - minchinweb/minchin.pelican.plugins.wikilinks: Support Wikilinks when generating Pelican sites</a>). Under the hood, it scansÂ for <code>[[...]]</code> patterns after markdown processing and replaces themÂ with <code>&lt;a&gt;</code> links to the target pageâ€™s <span class="caps">URL</span> (<a href="https://github.com/MinchinWeb/minchin.pelican.plugins.wikilinks/#:~:text=In%20basic%20usage%2C%20this%20allow,is%20finished" rel="noopener noreferrer" target="_blank">GitHub - minchinweb/minchin.pelican.plugins.wikilinks: Support Wikilinks when generating Pelican sites</a>). This makes cross-referencing content as easy as in tools like Obsidian or Roam. (We will enforce unique filenames for notes to avoid ambiguous links (<a href="https://github.com/MinchinWeb/minchin.pelican.plugins.wikilinks/#:~:text=Known%20Issues" rel="noopener noreferrer" target="_blank">GitHub - minchinweb/minchin.pelican.plugins.wikilinks: Support Wikilinks when generating Pelican sites</a>).) </p>
<p><strong>Backlinks:</strong> To achieve bi-directional linking (seeing what links back to a page), we can create a custom Pelican plugin or utilize the siteâ€™s metadata. During the build, we can collect all the wiki link references: e.g. maintain a dictionary mapping each target page to a list of pages that mentioned it. Then extend Pelicanâ€™s article context to include a â€œbacklinksâ€ list for each article. Finally, in the article template, if backlinks exist, render a section â€œ<strong>Linked from:</strong> â€¦â€ listing those referring pages. This requires a custom plugin that hooks into Pelicanâ€™s generation phase (using signalsÂ like <code>article_generator_finalized</code>) to gather links and inject the data. The effort is manageable given Pelicanâ€™s plugin <span class="caps">API</span> (Python hooks), and ensures every page ends with a list of other notes that link to it, reinforcing the wiki-like navigation. If writing a plugin from scratch, weâ€™d parse each articleâ€™s <span class="caps">HTML</span> (or use the internal link map from the Wikilinks plugin) to identifyÂ outgoing <code>href</code>s pointing inside the site, then invert thatÂ mapping. </p>
<p>Pelicanâ€™s standard linking syntaxÂ (<code>{filename}target.md</code>) could also be used for internal links (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=the%20other%20content%20will%20be,placed%20after%20site%20generation" rel="noopener noreferrer" target="_blank">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>) (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=,filename%7D%2Farticle2.md" rel="noopener noreferrer" target="_blank">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>), but the wiki-style is more intuitive for a digital garden workflow. With the Wikilinks plugin and a backlinks plugin, the site will have <strong>fully connected pages</strong> with automaticÂ references. </p>
<h2>Custom Content Types <span class="amp">&amp;</span>Â Templates</h2>
<p>One strength of Pelican is its flexible metadata and templating, which we leverage to define <strong>custom article types</strong>Â like <code>RECIPE</code> or <code>TRIP</code>. All Markdown files can include arbitrary front-matter fields (as long as they donâ€™t conflict with reserved keywords) (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=This%20is%20the%20content%20of,my%20super%20blog%20post" rel="noopener noreferrer" target="_blank">Writing content â€” Pelican 4.7.2 documentation</a>) (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=,false" rel="noopener noreferrer" target="_blank">Writing content â€” Pelican 4.7.2 documentation</a>). We define a metadataÂ field <code>Type</code> (or use a tag/category) to denote the content type, and add any custom fields needed. For example, a recipe mightÂ have: </p>
<div class="highlight"><pre><span></span><code>Title: Chocolate Chip Cookies  
Date: 2025-03-01  
Type: recipe  
Servings: 4  
Prep_Time: 15 min  
Cook_Time: 10 min  
Ingredients: 
<span class="w">  </span><span class="k">-</span><span class="w"> </span>Flour 
<span class="w">  </span><span class="k">-</span><span class="w"> </span>Sugar 
<span class="w">  </span><span class="k">-</span><span class="w"> </span>Chocolate chips 
Steps: 
<span class="w">  </span><span class="k">1.</span> Preheat ovenâ€¦  
<span class="w">  </span><span class="k">2.</span> Mix ingredientsâ€¦  
Template: recipe  &lt;!-- use a custom Jinja template --&gt;
</code></pre></div>
<p>In this case, weÂ set <code>Template: recipe</code> which tells Pelican to render this pageÂ with <code>recipe.html</code> instead of the default template (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=match%20at%20L131%20,to%20use%20for%20this%20article%2Fpage" rel="noopener noreferrer" target="_blank">Writing content â€” Pelican 4.7.2 documentation</a>). We will create separate Jinja2 templatesÂ (e.g., <code>recipe.html</code>, <code>trip.html</code>) in the theme. These templates extend the base layout but present the content in a specialized way. For instance, <strong><code>recipe.html</code></strong> can format the Ingredients list as a checklist, show Prep/Cook time in a sidebar, etc., whereas <strong><code>trip.html</code></strong> might display location info, dates, and an image gallery differently. Pelican will pass all front-matter fields into the template context, so fieldsÂ like <code>Ingredients</code> or <code>Location</code> become accessible variables. We can thus iterateÂ over <code>recipe.ingredients</code> in Jinja to output an <span class="caps">HTML</span> list, for example. This approach gives us <strong>structured content</strong> without needing a database â€“ essentially a lightweight <span class="caps">CMS</span> defined via markdownÂ metadata. </p>
<p>Pelicanâ€™s flexibility here means we can support any number of content types. If needed, we could also write a Pelican plugin to validate that required fields are present for each type (ensuring, say,Â every <code>Type: recipe</code> file has an Ingredients list) or even generate additional pages (e.g., an index of all recipes). But even without extra plugins, using Jinja templates keyed on a metadata flag is sufficient and keeps thingsÂ simple. </p>
<h2>Beautiful Theming (Ghost-InspiredÂ Design)</h2>
<p>We want the site to look modern and polished â€“ more like a blog or magazine than a raw wiki. Pelican supports theming with Jinja2 templates and static <span class="caps">CSS</span>, allowing full control over design (<a href="https://github.com/getpelican/pelican#:~:text=,rich%20plugin%20ecosystem%3A%20Pelican%20Plugins" rel="noopener noreferrer" target="_blank">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>). We can start from an existing <strong>Ghost-inspired theme</strong> for Pelican to save time. For example, the <em>Casper</em> theme (Ghostâ€™s default) has been ported to Pelican as <strong>Casper2Pelican</strong> (<a href="https://github.com/abr4xas/Casper2Pelican#:~:text=Casper2Pelican" rel="noopener noreferrer" target="_blank">GitHub - abr4xas/Casper2Pelican: The default personal blogging theme for pelican</a>), and others like <em>Nicholas</em> or <em>Ghastly</em> offer clean Ghost-like aesthetics. These themes feature modern typography, responsive layout, and support for cover images and author profiles. The Casper2Pelican <span class="caps">README</span> notes itâ€™s based on Ghostâ€™s default and even supports author bios, social sharing, and header images via metadata (<a href="https://github.com/abr4xas/Casper2Pelican#:~:text=,and%20share%20buttons%20on%20article" rel="noopener noreferrer" target="_blank">GitHub - abr4xas/Casper2Pelican: The default personal blogging theme for pelican</a>). Using such a theme (or a similar Pelican theme) gives us a head start with a <strong>beautiful design</strong> consistent with popularÂ blogs. </p>
<p>We can customize the theme further to match our vision. This might include: 
- <strong>Header images</strong> for articles: e.g. using a metadataÂ field <code>Image: path/to/cover.jpg</code> which the template uses as a banner at the top of a post (Casper2Pelican already checksÂ an <code>image</code> field for header image (<a href="https://github.com/abr4xas/Casper2Pelican#:~:text=,and%20share%20buttons%20on%20article" rel="noopener noreferrer" target="_blank">GitHub - abr4xas/Casper2Pelican: The default personal blogging theme for pelican</a>)). 
- <strong>Navigation and Home Page:</strong> Weâ€™ll create a custom home page instead of a simple blog index. For instance, design a welcome pageÂ (<code>content/pages/home.md</code>) with an overview and featured posts. Using Pelicanâ€™s pages feature, weÂ set <code>SAVE_AS = 'index.html'</code> for that page so it becomes the landing page. The normal blog index (listing latest notes) can be generatedÂ at <code>/archive/</code> or a different <span class="caps">URL</span>. 
- <strong><span class="caps">CSS</span> Framework:</strong> Optionally, incorporate a modern <span class="caps">CSS</span> framework or utility library (e.g. Tailwind or Bootstrap) to easily achieve a clean look for elements like tables, code blocks, callouts, etc., if the chosen theme doesnâ€™t already handle it. Many Pelican themes use Bootstrap 4/5 or pure <span class="caps">CSS</span>. We should ensure the styling for wiki link references and backlinks section is cohesive (e.g., backlinks as a small italicized list at bottom). 
- <strong>Mobile-friendly design:</strong> The theme should be responsive; Ghost-based themes typically are. Weâ€™ll verify that navigation (category lists, tag pages) collapses nicely onÂ mobile. </p>
<p>By leveraging an existing theme and tweaking it, we meet the requirement of a <strong>â€œbeautiful design inspired by modern blogsâ€</strong>. Pelicanâ€™s theme system separates content from presentation, so we can iterate on the look independently. The end result wonâ€™t feel like a bare-bones dev wiki â€“ instead, it will have polished typography, spacing, and visuals similar to a Ghost blog (as evidenced by the Casper2Pelican screenshot and demo blogs (<a href="https://github.com/abr4xas/Casper2Pelican#:~:text=Demo" rel="noopener noreferrer" target="_blank">GitHub - abr4xas/Casper2Pelican: The default personal blogging theme for pelican</a>)). </p>
<h2>Multi-Language Support <span class="amp">&amp;</span> <span class="caps">AI</span>Â Translations</h2>
<p>The digital garden will be <strong>multilingual</strong>, serving content in (for example) English and Spanish. Pelican, with the <strong><code>i18n_subsites</code></strong> plugin, can generate a multi-language site where each language is a sub-site. We organize content by language â€“Â e.g. <code>content/en/...</code> and <code>content/es/...</code> â€“ or includeÂ a <code>Lang</code> metadata on each file. Pelicanâ€™s multi-language support allows each article to have translated counterparts identified by the same slug andÂ a <code>lang</code> code (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=,without%20extension" rel="noopener noreferrer" target="_blank">Writing content â€” Pelican 4.7.2 documentation</a>). At build time, the i18n plugin produces separate output folders for each language (or language-specific paths) and can generate a language switcher. The Pelican docs highlight <em>â€œpublication of articles in multiple languagesâ€</em> as a core feature (<a href="https://github.com/getpelican/pelican#:~:text=,rich%20plugin%20ecosystem%3A%20Pelican%20Plugins" rel="noopener noreferrer" target="_blank">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>). In practice, you mightÂ have <code>my-article.en.md</code> and <code>my-article.es.md</code>. If a translation is missing, Pelican can default to the original or we can configure fallbackÂ behavior.</p>
<p><strong>Auto-fill with <span class="caps">AI</span>:</strong> To meet the requirement of filling untranslated content using <span class="caps">AI</span>, we introduce a <strong>translation pipeline step</strong>. This would run <em>before</em> or <em>during</em> the build. For any article that lacks a manual translation, a script can automatically generate one via an <span class="caps">AI</span> translation service. For example, we could use a translation <span class="caps">API</span> (like DeepL or Google Cloud Translate) or an <span class="caps">AI</span> model (like <span class="caps">GPT</span>-4) through their Python SDKs to translate English Markdown to Spanish Markdown. The build workflow could be:
1. Detect articles that exist in English but not in Spanish (perhaps by scanningÂ the <code>content/en</code> vs <code>content/es</code> directories).
2. For each missing translation, call the <span class="caps">AI</span> <span class="caps">API</span> to produce a translated Markdown text. Preserve the front matterÂ (with <code>lang: es</code> and a note that itâ€™s auto-generated) and have the body translated. 
3. Save these generated filesÂ in <code>content/es/...</code> so that Pelican includes them in the site generation. Optionally mark them with a flagÂ (e.g. <code>Translation: machine</code>) that the template can use to display a disclaimer banner like â€œğŸ¤– This is an <span class="caps">AI</span>-translated version; it may containÂ errors.â€ </p>
<p>Because this process can be time-consuming or cost <span class="caps">API</span> usage, weâ€™d integrate it as an optional step (only generate if the file isnâ€™t already there, and possibly commit the result to the repo so itâ€™s reused). This way, untranslated content is automatically populated, ensuring the Spanish site is never missing a page â€“ it will either have a human-written translation or an <span class="caps">AI</span>-providedÂ one. </p>
<p>Pelicanâ€™s i18n plugin will link between language versions of each page (it adds link rel=â€alternateâ€ and allows template language switchers). We can thus have a language toggle on each page. Users will see a fully bilingual site, largely maintained by writing primarily in one language and letting <span class="caps">AI</span> assist with theÂ other. </p>
<p>All tools here are Python-friendly: Pelicanâ€™s plugin is Python, and calling an <span class="caps">AI</span> translation (via requests or an <span class="caps">SDK</span>) is straightforward to script. This setup future-proofs the site â€“ content creators can focus on one language, and <span class="caps">AI</span> can help keep other languagesÂ up-to-date. </p>
<h2>Content Access Control (Roles <span class="amp">&amp;</span>Â Authentication)</h2>
<p>Even though the site is static, we need <strong>access roles</strong> for certain content (public vs friends/family vs private drafts). We can handle this by a combination of build-time filtering and client-side authentication usingÂ Auth0. </p>
<p><strong>Drafts <span class="amp">&amp;</span> Unlisted Posts:</strong> Pelican supportsÂ a <code>Status</code> metadata. If we mark anÂ article <code>Status: draft</code>, Pelican will not publish it (by default (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=,without%20extension" rel="noopener noreferrer" target="_blank">Writing content â€” Pelican 4.7.2 documentation</a>) (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=If%20your%20articles%20should%20be,include%20the%20status%20in%20the" rel="noopener noreferrer" target="_blank">Writing content â€” Pelican 4.7.2 documentation</a>)ã€‘, so drafts remain excluded from the generated site. For â€œfriends/familyâ€ posts that are finished but should not be public, we can useÂ Pelicanâ€™s <code>hidden</code> status (or simply exclude them from indexes).Â A <code>Status: hidden</code> post <em>is</em> generated as an <span class="caps">HTML</span> page but is omitted from feeds and listing (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=on%20the%20index%20page%20nor,any%20category%20or%20tag%20page" rel="noopener noreferrer" target="_blank">Writing content â€” Pelican 4.7.2 documentation</a>)ã€‘. This creates an <strong>unlisted page</strong> â€“ only accessible if you know the <span class="caps">URL</span>. We can distribute those URLs privately. This provides basic obscurity but not trueÂ security. </p>
<p>For stronger protection, we integrate <strong>Auth0 authentication</strong> into the static site. At build time, we decide which pages require login. For example, we might add a metadataÂ flag <code>Visibility: friends</code> or <code>auth_required: true</code> for pages that should only be seen by certain users. The build process can then inject an Auth0 login gate into those pages. Concretely, we can create a Jinja template snippet that includes the Auth0 JavaScript <span class="caps">SDK</span> and a script to enforce login. Each protected page, when rendered, would contain somethingÂ like: </p>
<div class="highlight"><pre><span></span><code><span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">"protected-content"</span><span class="p">&gt;</span> ... full content ... <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">"https://cdn.auth0.com/js/auth0-spa-js/1.XX/auth0-spa.min.js"</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="w">  </span><span class="c1">// Initialize Auth0 client</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">auth0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">createAuth0Client</span><span class="p">({</span><span class="w"> </span><span class="nx">domain</span><span class="o">:</span><span class="w"> </span><span class="s2">"YOUR_DOMAIN"</span><span class="p">,</span><span class="w"> </span><span class="nx">client_id</span><span class="o">:</span><span class="w"> </span><span class="s2">"YOUR_CLIENTID"</span><span class="p">,</span><span class="w"> </span><span class="nx">cacheLocation</span><span class="o">:</span><span class="w"> </span><span class="s1">'localstorage'</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">isAuthenticated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">auth0</span><span class="p">.</span><span class="nx">isAuthenticated</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">isAuthenticated</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'protected-content'</span><span class="p">).</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'none'</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Show a login button or auto-login:</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">auth0</span><span class="p">.</span><span class="nx">loginWithRedirect</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'protected-content'</span><span class="p">).</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'block'</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div>
<p>This is a sketch, but the idea is the page will require an Auth0 login before showing content. Auth0 will handle the login redirect and token management (the Auth0 <span class="caps">SPA</span> <span class="caps">SDK</span> is used as shown in Auth0â€™s Gatsby exampl (<a href="https://auth0.com/blog/securing-gatsby-with-auth0/#:~:text=How%20to%20Secure%20GatsbyJS%20Sites,management%20on%20a%20GatsbyJS" rel="noopener noreferrer" target="_blank">How to Secure GatsbyJS Sites with Auth0 for Authentication</a>) (<a href="https://auth0.com/blog/securing-gatsby-with-auth0/#:~:text=How%20to%20Secure%20GatsbyJS%20Sites,management%20on%20a%20GatsbyJS" rel="noopener noreferrer" target="_blank">How to Secure GatsbyJS Sites with Auth0 for Authentication</a>)ã€‘). At build-time we embed the Auth0 credentials (domain, client <span class="caps">ID</span>) which are not sensitive. We do <strong>not</strong> include any secret keys in the static code. After login, the content div becomesÂ visible. </p>
<p><strong>Role-Based Access:</strong> Auth0 supports role claims in token (<a href="https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles#:~:text=We%20provide%20various%20functions%20to,or%20the%20Auth0%20Management%20API" rel="noopener noreferrer" target="_blank">Manage Role-Based Access Control Roles - Auth0</a>)ã€‘. If we want to distinguish â€œfriends and familyâ€ vs â€œeditorsâ€, we can assign roles in Auth0 (e.g., a user role â€œfamilyâ€ or an allowed email list). The front-end script can then query the userâ€™s profile/claims after login and decide whether to show the page. For example, a page for â€œfamilyâ€ couldÂ check <code>if(user.roles.includes('family')) { show content } else { hide and show "Access Denied" }</code>. This check is done client-side with the data from Auth0. While not foolproof (since the <span class="caps">HTML</span> is technically delivered), we could also choose not to even deploy certain files publicly. Another approach is to generate two versions of the site: one public (excluding private pages entirely) and one for authenticated use. However, since the requirement is static hosting on GitHub Pages (which doesnâ€™t support server-side auth), using Auth0â€™s client-side gating is a practical solutio (<a href="https://community.auth0.com/t/protecting-static-website-using-auth0-but-using-existing-users/76359#:~:text=Hello,Auth0%20JavaScript%20SDK%20Quickstarts%3A%20Login" rel="noopener noreferrer" target="_blank">Protecting Static Website using Auth0 but using existing users - Auth0 Community</a>)ã€‘. </p>
<p>In summary, public content will be generated normally and listed on the site. Private content will either be hidden from listings or not present at all in the public build. If hidden but present, they will have Auth0 code embedded to ensure only authorized users can easily view them. This setup turns the static site into a pseudo-protected site. Itâ€™s important to note that truly secure content shouldnâ€™t be published to public servers at all â€“ for highly sensitive info, one might maintain it in a private repo or use a hosting service with access control. But for â€œfriends/familyâ€ level privacy, this approach (unlisted pages + Auth0 login on the front-end) is sufficient and commonly used. Auth0â€™s documentation and quickstarts will guide the integration of their <span class="caps">SPA</span> <span class="caps">SDK</span> into our static pages, making the processÂ straightforward. </p>
<h2>Tags, Indexes, and NavigationÂ Pages</h2>
<p>We will support <strong>multiple index pages</strong> to help discover content: by tag, by category, by popularity, etc. Pelican automatically creates index pages for <strong>tags and categories</strong>. Each tag will get a page listing all articles with that tag (Pelicanâ€™s templates and generators handle this if enabled). Same for categories (and with our nested scheme, categories like â€œdata_scienceâ€ under â€œtech/devâ€ will show all related posts). Weâ€™ll ensure the theme includes pages for tags/categories in the navigation or as part of aÂ sitemap. </p>
<p>For a <strong>â€œMost Readâ€</strong> page, since the site is static, we need to gather view statistics from an external source. One option is to use an analytics service (like Google Analytics or Plausible) on the site, then periodically retrieve pageview counts. We can incorporate a <span class="caps">JSON</span> of page view stats (keyed by <span class="caps">URL</span> or slug) and have a build step to sort articles by views and generate a page of â€œTop 10 most read articles.â€ This would be a custom script that runs before site generation to update a data file (or we use Pelicanâ€™sÂ [<code>READERS</code> or data files plugin] to ingest a <span class="caps">CSV</span>/<span class="caps">JSON</span>). Alternatively, if we donâ€™t have analytics integration, we might define â€œmost readâ€ manually or by other metrics (like an editorial choice or proxy like time since posted). But assuming we have <span class="caps">GA</span>, we could use Google Analytics Reporting <span class="caps">API</span> via Python to get the most viewed URLs and then produce a static page listing those (with links and maybe viewÂ counts). </p>
<p>We also plan a <strong>handcrafted home page</strong> as mentioned earlier. This will likely be a static page (written in Markdown for convenience) that is set as the landing page. We can curate content here â€“ e.g., a welcome message, featured posts in different categories, etc. Because Pelican allows creating arbitrary pages (any fileÂ under <code>content/pages/</code> by default) and does not force the blog index to be the root, we can completely customize the homepage. For example, the homepage could even be written as a Jinja template itself if we want dynamic content (Pelican allows creating templates for pages). But simpler, we can hardcode or use shortcodes for pulling in snippets (Pelican plugins exist for including content or definingÂ shortcodes). </p>
<p><strong>Navigation:</strong> The site will have a menu (likely in the header) linking to key index pages: e.g. <em>Blog</em>, <em>Categories</em>, <em>Tags</em>, <em>About</em>, <em>Languages</em>. We will enableÂ Pelicanâ€™s <code>DISPLAY_PAGES_ON_MENU</code> and <code>DISPLAY_CATEGORIES_ON_MENU</code> settings as needed, or manually define a menu in config for finer control. The Ghost-based theme we use might already support a configurable menu. Weâ€™ll include a link to the â€œAll Tagsâ€ page and maybe a link to â€œAll Postsâ€ archive. If the site becomes large, we could add a search functionality; Pelican has a plugin for search that works by building a <span class="caps">JSON</span> index used by a <span class="caps">JS</span> script (for example, <strong>Tipue Search</strong> pluginÂ or <code>pelican-search</code> which provides Lunr.js searc (<a href="https://blog.stanleysolutionsnw.com/adding-search-to-my-pelican-blog-site.html#:~:text=Adding%20Search%20to%20my%20Pelican,based%20system" rel="noopener noreferrer" target="_blank">Adding Search to my Pelican Blog Site | Stanley Solutions Blog</a>)ã€‘). That would add a small <span class="caps">JS</span> (still lightweight) to enable full-text search on the client side, which is a nice enhancement for a digital garden. (This is optional but worth noting since gardens benefit fromÂ search.) </p>
<h2>Build Pipeline <span class="amp">&amp;</span> LinkÂ Validation</h2>
<p>To tie everything together, weâ€™ll set up a robust <strong>build pipeline</strong> (e.g., using GitHub Actions or similar <span class="caps">CI</span>) to automate site generation, validation, and deployment to GitHub Pages. The stages wouldÂ include: </p>
<ol>
<li>
<p><strong>Generate Site:</strong> Use Pelican to build the site. This involves installing the Python dependencies (Pelican and required pluginsÂ like <code>pelican-i18n_subsites</code>, <code>pelican-wikilinks</code>, etc., all available via pip), thenÂ running <code>pelican content -o output -s pelicanconf.py</code> (and possibly once per language if using i18n plugin in a certain way). The Pelican config will include all our settings (paths, plugins, theme,Â etc.). </p>
</li>
<li>
<p><strong>Validate Internal Links:</strong> After generation, we perform a link check focusing on internal links. We want to catch any broken references (especially from the wiki links or manual links). We can use an automated link checker â€“ for example, a tool like <strong>LinkChecker</strong> (Python)Â or <code>html-proofer</code>. A Python approach could be writing a small script that parses all output <span class="caps">HTML</span> files and verifies thatÂ every <code>&lt;a href&gt;</code> pointing to the same domain has a corresponding file. Since we have the list of output files, we can map URLs to files easily. Another approach is to use Pelicanâ€™s own link mapping: the Wikilinks plugin might warn if a target is missing. If not, our custom backlink plugin could also log missing targets. In any case, the <span class="caps">CI</span> can run a script to ensure no 404s for internal hyperlinks. If a broken link is found, the build should fail, alerting us to fix the reference or add the missing page. This step addresses the requirement of a <strong>build stage validating internal links</strong> â€“ essential in a wiki-like garden where content moves and many cross-linksÂ exist. </p>
</li>
<li>
<p><strong>Deploy to GitHub Pages:</strong> Once the site passes checks, the pipeline can deploy it. For GitHub Pages, that typically means pushingÂ the <code>output/</code> (static files) toÂ the <code>gh-pages</code> branch orÂ the <code>docs/</code> folder of the repository. We can use a <span class="caps">GH</span> Action for this, or even GitHub Pagesâ€™ native static publishing if we keep the outputÂ in <code>docs/</code>. The deployment must include all language versions (possibly in subfoldersÂ like <code>en/</code> and <code>es/</code> if configured) and all static assets. Since everything is static, deployment is as simple as uploading the files â€“ no server-side logicÂ needed. </p>
</li>
<li>
<p><strong>(Optional) Post-deploy Tasks:</strong> If using analytics for â€œmost readâ€ or if we want to purge a <span class="caps">CDN</span> cache, etc., those could be additional steps. But not strictly necessary for coreÂ functionality. </p>
</li>
</ol>
<p><strong>Actively Maintained Tools:</strong> All components in this stack are widely used and maintained. Pelican is a mature project (10k+ stars on GitHub, active as of 2025 (<a href="https://www.reddit.com/r/django/comments/oxuxg1/pelican_for_professional_website/#:~:text=pelican%20for%20professional%20website%20%3A,is%2C%20what%20is%20your" rel="noopener noreferrer" target="_blank">pelican for professional website : r/django - Reddit</a>)ã€‘, and its plugins (like Wikilinks and i18n) are actively kept up-to-date with Pelican release (<a href="https://github.com/MinchinWeb/minchin.pelican.plugins.wikilinks/#:~:text=Further%20configuration%20will%20depend%20on,file" rel="noopener noreferrer" target="_blank">GitHub - minchinweb/minchin.pelican.plugins.wikilinks: Support Wikilinks when generating Pelican sites</a>)ã€‘. Auth0 is a reliable commercial platform with extensive documentation and support for <span class="caps">SPA</span> integration. Any <span class="caps">AI</span> translation step can utilize stable APIs (Google Translate, DeepL) or libraries. By using established tools, we ensure longevity and communityÂ support. </p>
<h2>Summary of the RecommendedÂ Stack</h2>
<ul>
<li><strong>Pelican (Python Static Site Generator)</strong> â€“ Core engine for markdown-to-<span class="caps">HTML</span>, multi-language output, theming, and plugin (<a href="https://github.com/getpelican/pelican#:~:text=,rich%20plugin%20ecosystem%3A%20Pelican%20Plugins" rel="noopener noreferrer" target="_blank">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>)ã€‘.  </li>
<li><strong>Content Structure:</strong> Markdown files in a nested directory hierarchy, one article per folder with associated images/docs, using Pelicanâ€™s attach mechanism for bundling asset (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=Starting%20with%20Pelican%203,sibling%20of%20the%20linking%20document" rel="noopener noreferrer" target="_blank">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>) (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=%21%5BIcon%5D%28" rel="noopener noreferrer" target="_blank">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>)ã€‘.  </li>
<li><strong>PelicanÂ Plugins:</strong> </li>
<li><em>Wikilinks</em>Â for <code>[[wiki-style]]</code> link syntax between page (<a href="https://github.com/MinchinWeb/minchin.pelican.plugins.wikilinks/#:~:text=Usage%20Notes" rel="noopener noreferrer" target="_blank">GitHub - minchinweb/minchin.pelican.plugins.wikilinks: Support Wikilinks when generating Pelican sites</a>)ã€‘. </li>
<li><em>i18n_subsites</em> for multi-language site generation (creating language-specific versions of the site (<a href="https://siongui.github.io/2017/01/07/pelican-translate-string-according-to-default-language-in-theme/#:~:text=Pelican%20static%20site%20generator%20and,macro%20to%20achieve%20this%20goal" rel="noopener noreferrer" target="_blank">[Pelican] Translate String According to Default Language in Theme</a>)ã€‘. </li>
<li><em>Neighbors</em> (if using a theme that requires it) to get next/previous article links easil (<a href="https://github.com/abr4xas/Casper2Pelican#:~:text=Abr4xas%2C%20amendments%20by%20Colin%20Wren" rel="noopener noreferrer" target="_blank">GitHub - abr4xas/Casper2Pelican: The default personal blogging theme for pelican</a>)ã€‘. </li>
<li><em>Tipue Search or similar</em> (optional) for client-side search functionalit (<a href="https://blog.stanleysolutionsnw.com/adding-search-to-my-pelican-blog-site.html#:~:text=Adding%20Search%20to%20my%20Pelican,based%20system" rel="noopener noreferrer" target="_blank">Adding Search to my Pelican Blog Site | Stanley Solutions Blog</a>)ã€‘. </li>
<li>Custom plugins for backlink aggregation and any additional validation or content processing (<span class="caps">AI</span> translation insertion could also be done here or in <span class="caps">CI</span>). </li>
<li><strong>Templates/Theming:</strong> A responsive theme inspired by Ghostâ€™s <strong>Casper</strong> (e.g. Casper2Pelica (<a href="https://github.com/abr4xas/Casper2Pelican#:~:text=Casper2Pelican" rel="noopener noreferrer" target="_blank">GitHub - abr4xas/Casper2Pelican: The default personal blogging theme for pelican</a>)ã€‘ or another port) to provide a clean, modern <span class="caps">UI</span>. We will customize templates for special content types (recipes, trips) using Pelicanâ€™s template override featur (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=match%20at%20L131%20,to%20use%20for%20this%20article%2Fpage" rel="noopener noreferrer" target="_blank">Writing content â€” Pelican 4.7.2 documentation</a>)ã€‘ and front-matter metadata, and include visual enhancements (cover images, syntax highlighting for code, etc.). The design will emphasize readability and aesthetics, avoiding a technicalÂ look. </li>
<li><strong>Authentication:</strong> Auth0 <span class="caps">SPA</span> integration for protected sections. We do this by embedding Auth0â€™s <span class="caps">JS</span> and gating logic in pages marked as non-public. Auth0 manages the user accounts and login dialogs (e.g., via Google OAuth or email/password as configured), and the static site just includes the necessary scripts. This adds a slight <span class="caps">JS</span> dependency on those pages, but only for the sake of auth â€“ the overall site remains static andÂ content-focused. </li>
<li><strong>Build/Deployment Pipeline:</strong> Use GitHub Actions (or similar <span class="caps">CI</span>) to run the build. The pipeline will run Pelican, run a <strong>link checker</strong> to validate all internal references (preventing broken links in the graph), and then deploy to GitHub Pages. Content translations via <span class="caps">AI</span> can be automated in this pipeline as well, ensuring the latest content is available in allÂ languages. </li>
</ul>
<p>By combining these technologies, we get a <strong>robust, customizable, and beautiful digital garden system</strong> that meets all the listed requirements. All major components are Python-based (Pelican, plugins, build scripts), aligning with the preference for Python tooling. The architecture leverages static site best practices (pre-render everything for speed and simplicit (<a href="https://github.com/getpelican/pelican#:~:text=With%20Pelican%2C%20you%20can%20create,web%20server%20or%20hosting%20service" rel="noopener noreferrer" target="_blank">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>) (<a href="https://github.com/getpelican/pelican#:~:text=,is%20simple%20to%20host%20anywhere" rel="noopener noreferrer" target="_blank">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>)ã€‘) while layering on advanced features like backlinks, full-text search, and role-based access that are often missing from simpler static blogs. The result is a personal knowledge garden that is easy to write in (just Markdown in VSCode), easy to maintain (thanks to automation and plugin support), and delightful for readers in terms of appearance andÂ navigation. </p>
<p><strong>References:</strong> The selection of Pelican is supported by its official docs and community plugins, which confirm it can handle multi-language content, Markdown, and is extensibl (<a href="https://github.com/getpelican/pelican#:~:text=,rich%20plugin%20ecosystem%3A%20Pelican%20Plugins" rel="noopener noreferrer" target="_blank">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>) (<a href="https://github.com/MinchinWeb/minchin.pelican.plugins.wikilinks/#:~:text=Usage%20Notes" rel="noopener noreferrer" target="_blank">GitHub - minchinweb/minchin.pelican.plugins.wikilinks: Support Wikilinks when generating Pelican sites</a>)ã€‘. The Ghost-inspired design is facilitated by existing Pelican themes (e.g., Casper2Pelican) which explicitly aims to bring Ghostâ€™s default look to Pelica (<a href="https://github.com/abr4xas/Casper2Pelican#:~:text=Casper2Pelican" rel="noopener noreferrer" target="_blank">GitHub - abr4xas/Casper2Pelican: The default personal blogging theme for pelican</a>)ã€‘. Auth0 integration for static sites is a known approach (Auth0 provides <span class="caps">SPA</span> SDKs and guides for static site authentication flow (<a href="https://community.auth0.com/t/protecting-static-website-using-auth0-but-using-existing-users/76359#:~:text=Hello,Auth0%20JavaScript%20SDK%20Quickstarts%3A%20Login" rel="noopener noreferrer" target="_blank">Protecting Static Website using Auth0 but using existing users - Auth0 Community</a>)ã€‘). All these pieces together form a cohesive stack to realize the envisioned digitalÂ garden.</p>
<h1>Follow upÂ questions</h1>
<p>While ponderimg (and soon testing) the suggested solution, some more questions came up toÂ me.</p>
<h2>Changing theÂ structure</h2>
<ul>
<li>How does the system behave when I move an article feom one location of the tree toÂ another?</li>
<li>How does the system behave when I rename anÂ article?</li>
<li>How does the system behave when I delete anÂ article?</li>
<li>How does the system behave when I rename aÂ folder?</li>
<li>How does the system behave when I delete aÂ folder?</li>
</ul>
<h2>Articles orÂ Pages?</h2>
<p>From the <a href="https://docs.getpelican.com/en/latest/content.html" rel="noopener noreferrer" target="_blank">Pelican documentation</a>:</p>
<blockquote>
<p>Pelican considers â€œarticlesâ€ to be chronological content, such as posts on a blog, and thus associated with a date.
The idea behind â€œpagesâ€ is that they are usually not temporal in nature and are used for content that does not change very often (e.g., â€œAboutâ€ or â€œContactâ€Â pages).</p>
</blockquote>
<p>So what should <strong>my</strong> articles be? In my article concept the date is not too important. But maybe the workflow to edit Pelican articles is easier than the one to editÂ pages?</p>
<h1>PlayingÂ around</h1>
<p>So I create a <a href="https://github.com/tillg/playground_pelican" rel="noopener noreferrer" target="_blank">github repo</a> and start playimngÂ around.</p>
      <div id="giscus">
        <script src="https://giscus.app/client.js" data-repo="tillg/grtnr.com_2024" data-repo-id="R_kgDONYRp_Q"
          data-category="Q&A" data-category-id="DIC_kwDONYRp_c4Cm0cH" data-mapping="pathname" data-strict="0"
          data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme"
          data-lang="en" crossorigin="anonymous" async>
      </script>
  </div>

  </div>
</div>
      </div>

      <label for="sidebar-checkbox" class="sidebar-toggle"></label>

      <script>
        (function(document) {
          var i = 0;
          // snip empty header rows since markdown can't
          var rows = document.querySelectorAll('tr');
          for(i=0; i<rows.length; i++) {
            var ths = rows[i].querySelectorAll('th');
            var rowlen = rows[i].children.length;
            if (ths.length > 0 && ths.length === rowlen) {
              rows[i].remove();
            }
          }
        })(document);
      </script>

      <script>
        /* Lanyon & Poole are Copyright (c) 2014 Mark Otto. Adapted to Pelican 20141223 and extended a bit by @thomaswilley */
        (function(document) {
          var toggle = document.querySelector('.sidebar-toggle');
          var sidebar = document.querySelector('#sidebar');
          var checkbox = document.querySelector('#sidebar-checkbox');
          document.addEventListener('click', function(e) {
            var target = e.target;
            if(!checkbox.checked ||
            sidebar.contains(target) ||
            (target === checkbox || target === toggle)) return;
            checkbox.checked = false;
            }, false);
            })(document);
      </script>
        <script src="/theme/js/giscus-comments.js"></script>

     </div>
  </body>
</html>